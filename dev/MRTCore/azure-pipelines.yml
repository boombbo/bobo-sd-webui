# Universal Windows Platform
# Build a Universal Windows Platform project using Visual Studio.
# Add steps that test and distribute an app, save build artifacts, and more:
# https://aka.ms/yaml

name: $(BuildDefinitionName)-$(date:yyMM).$(date:dd)$(rev:rrr)

trigger:
- master

# Only MRTCore pipeline is registered for signing
variables:
  codeSign: ${{ eq(variables['System.definitionId'], '1356') }}

jobs:
- job: Build
  pool:
    name: Package ES Standard Build
  
  variables:
    solution: '**/*.sln'
    buildConfiguration: 'Release'
    appxPackageDir: '$(build.artifactStagingDirectory)\AppxPackages\\'
  
  steps:
  - task: PkgESSetupBuild@10
    displayName: 'Package ES - Setup Build'
    inputs:
      ProductName: MRT Core
      useDfs: false
      branchVersion: false
      extSync: false
  
#  - task: powershell@2
#    displayName: 'Installing .NET SDK'
#    inputs:
#      targetType: filePath
#      workingDirectory: $(Build.SourcesDirectory)\build
#      filePath: $(Build.SourcesDirectory)\build\DownloadDotNetCoreSdk.ps1
  
#  - task: BatchScript@1
#    displayName: 'Use .NET SDK'
#    inputs:
#      filename: '$(Build.SourcesDirectory)\build\SetDotnetVars.cmd'
#      arguments: '$(Build.SourcesDirectory)'
#      modifyEnvironment: true

  - task: UseDotNet@2
    inputs:
      packageType: 'sdk'
      useGlobalJson: true
      workingDirectory: '$(Build.SourcesDirectory)'

#  - task: BatchScript@1
#    displayName: 'Debug'
#    inputs:
#      filename: '$(Build.SourcesDirectory)\build\debug-pipeline.cmd'

  - task: NuGetToolInstaller@1
    displayName: 'Use NuGet 5.6'
    inputs:
      versionSpec: 5.6
    continueOnError: true

  - task: NuGetCommand@2
    displayName: 'NuGet restore of MrtCore'
    inputs:
      command: 'restore'
      restoreSolution: '$(Build.SourcesDirectory)\mrt\MrtCore.sln'
      feedsToUse: 'config'
      nugetConfigPath: '$(Build.SourcesDirectory)\mrt\NuGet.Config'
  
  - task: VSBuild@1
    displayName: 'build MrtCore x86'
    inputs:
      platform: 'x86'
      buildPlatform: 'x86'
      solution: '$(Build.SourcesDirectory)\mrt\MrtCore.sln'
      configuration: '$(buildConfiguration)'
      msbuildArgs: '/p:AppxBundlePlatforms="x86" /p:AppxPackageDir="$(appxPackageDir)" /p:AppxBundle=Always /p:UapAppxPackageBuildMode=StoreUpload'
  
  - task: VSBuild@1
    displayName: 'build MrtCore x64'
    inputs:
      platform: 'x64'
      buildPlatform: 'x64'
      solution: '$(Build.SourcesDirectory)\mrt\MrtCore.sln'
      configuration: '$(buildConfiguration)'
      msbuildArgs: '/p:AppxBundlePlatforms="x64" /p:AppxPackageDir="$(appxPackageDir)" /p:AppxBundle=Always /p:UapAppxPackageBuildMode=StoreUpload'

  - task: VSBuild@1
    displayName: 'build MrtCore ARM64'
    inputs:
      platform: 'ARM64'
      buildPlatform: 'x64'
      solution: '$(Build.SourcesDirectory)\mrt\MrtCore.sln'
      configuration: '$(buildConfiguration)'
      msbuildArgs: '/p:AppxBundlePlatforms="ARM64" /p:AppxPackageDir="$(appxPackageDir)" /p:AppxBundle=Always /p:UapAppxPackageBuildMode=StoreUpload'
  
  - task: VSTest@2
    displayName: 'test x86'
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: |
        **\*test*.dll
        !**\*TestAdapter.dll
        !**\TE.*.dll
        !**\obj\**
      searchFolder: '$(Build.BinariesDirectory)\Release\win32'
      testRunTitle: 'test x86'
      platform: 'x86'
      configuration: 'Release'
  
  - task: VSTest@2
    displayName: 'test x64'
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: |
        **\*test*.dll
        !**\*TestAdapter.dll
        !**\TE.*.dll
        !**\obj\**
      searchFolder: '$(Build.BinariesDirectory)\Release\x64'
      testRunTitle: 'test x64'
      platform: 'x64'
      configuration: 'Release'

  - task: ComponentGovernanceComponentDetection@0
    inputs:
      scanType: 'Register'
      verbosity: 'Verbose'
      alertWarningLevel: 'Medium'
      failOnAlert: true

  # The winmd is arch agnostic. For signing convenience, we group the winmd with the x86 binaries.
  - task: CopyFiles@2
    displayName: 'copy x86 for signing'
    inputs:
      SourceFolder: '$(Build.BinariesDirectory)\Release\win32'
      Contents: |
        mrm.dll
        mrm.lib
        mrm.pdb
        Microsoft.ApplicationModel.Resources\Microsoft.ApplicationModel.Resources.dll
        Microsoft.ApplicationModel.Resources\Microsoft.ApplicationModel.Resources.winmd
        Microsoft.ApplicationModel.Resources\Microsoft.ApplicationModel.Resources.pdb
      TargetFolder: '$(Build.ArtifactStagingDirectory)\raw\lib\x86'
      flattenFolders: true

  # We build the projection binaries for AnyCPU. For convenience though, we group these binaries with the x86
  # content for signing. Later, after signing, we deploy the binaries to an arch non-specific location in the
  # NuGet package (specifically, lib\net5.0-windows\ and lib\netstandard2.0-windows\).
  - task: CopyFiles@2
    displayName: 'copy projection for signing'
    inputs:
      SourceFolder: '$(Build.BinariesDirectory)\Release\AnyCPU\Microsoft.ApplicationModel.Resources.Projection'
      Contents: |
        net5.0\Microsoft.ApplicationModel.Resources.Projection.dll
        net5.0\Microsoft.ApplicationModel.Resources.Projection.pdb
        netstandard2.0\Microsoft.ApplicationModel.Resources.Projection.dll
        netstandard2.0\Microsoft.ApplicationModel.Resources.Projection.pdb
      TargetFolder: '$(Build.ArtifactStagingDirectory)\raw\lib\x86'
      flattenFolders: false
  
  # Ignore the winmd in the x64 build output. The winmd file is arch agnostic, we just use the x86 one for all archs
  # when creating the NuGet package below.
  - task: CopyFiles@2
    displayName: 'copy x64 for signing'
    inputs:
      SourceFolder: '$(Build.BinariesDirectory)\Release\x64'
      Contents: |
        mrm.dll
        mrm.lib
        mrm.pdb
        Microsoft.ApplicationModel.Resources\Microsoft.ApplicationModel.Resources.dll
        Microsoft.ApplicationModel.Resources\Microsoft.ApplicationModel.Resources.pdb
      TargetFolder: '$(Build.ArtifactStagingDirectory)\raw\lib\x64'
      flattenFolders: true

  # Ignore the winmd in the x64 build output. The winmd file is arch agnostic, we just use the x86 one for all archs
  # when creating the NuGet package below.
  - task: CopyFiles@2
    displayName: 'copy ARM64 for signing'
    inputs:
      SourceFolder: '$(Build.BinariesDirectory)\Release\ARM64'
      Contents: |
        mrm.dll
        mrm.lib
        mrm.pdb
        Microsoft.ApplicationModel.Resources\Microsoft.ApplicationModel.Resources.dll
        Microsoft.ApplicationModel.Resources\Microsoft.ApplicationModel.Resources.pdb
      TargetFolder: '$(Build.ArtifactStagingDirectory)\raw\lib\ARM64'
      flattenFolders: true

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Artifact: Binaries'
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)\raw'
      ArtifactName: 'binaries_raw'

- job: Sign
  condition: and(succeeded(), eq(variables.codeSign, true))
  dependsOn:
    - Build
  pool:
    name: Package ES Standard Build
  
  variables:
    solution: '**/*.sln'
    appxPackageDir: '$(build.artifactStagingDirectory)\AppxPackages\\'

  strategy:
    maxParallel: 3
    matrix:
      Release_x86:
        buildPlatform: 'x86'
        buildConfiguration: 'Release'
      Release_x64:
        buildPlatform: 'x64'
        buildConfiguration: 'Release'
      Release_ARM64:
        buildPlatform: 'ARM64'
        buildConfiguration: 'Release'

  steps:
  - task: DownloadBuildArtifacts@0
    displayName: 'Download: Raw Binaries'
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'binaries_raw'
      downloadPath: '$(Build.ArtifactStagingDirectory)\raw'
  
  - task: PkgESCodeSign@10
    env:
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    inputs:
      signConfigXml: 'SignConfig.xml'
      inPathRoot: '$(BUILD.ArtifactStagingDirectory)\raw\binaries_raw\lib'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Artifact: Signed Binaries'
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw'
      ArtifactName: 'signedbinaries_$(BuildPlatform)'

- job: Publish
  dependsOn:
    - Build
    - Sign
  condition: and(in(dependencies.Build.result, 'Succeeded'), in(dependencies.Sign.result, 'Succeeded', 'Skipped'))
  pool:
    name: Package ES Standard Build
  
  variables:
    solution: '**/*.sln'
    buildPlatform: 'Any CPU'
    buildConfiguration: 'Release'
    appxPackageDir: '$(build.artifactStagingDirectory)\AppxPackages\\'
    Major: '1'
    Minor: '0'
    Patch: '0'

  steps:
  - task: DownloadBuildArtifacts@0
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'Download: Signed Binaries x86'
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'signedbinaries_x86'
      downloadPath: '$(Build.ArtifactStagingDirectory)\raw'

  - task: DownloadBuildArtifacts@0
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'Download: Signed Binaries x64'
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'signedbinaries_x64'
      downloadPath: '$(Build.ArtifactStagingDirectory)\raw'

  - task: DownloadBuildArtifacts@0
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'Download: Signed Binaries ARM64'
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'signedbinaries_ARM64'
      downloadPath: '$(Build.ArtifactStagingDirectory)\raw'

# START of copying files into their final package location.

  # The winmd is arch agnostic. For signing convenience, we group it with the x86 binaries.
  # So, here, we copy from the x86 location to an arch agnostic location.
  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'copy winmd'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\signedbinaries_x86\lib\x86'
      Contents: |
        signed\Microsoft.ApplicationModel.Resources.winmd
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\uap10.0\'
      flattenFolders: true

  # We build the projection binaries for AnyCPU. For convenience though, we group these binaries with other x86
  # binaries for signing. That's why we're copying from the x86 location but deploying to an arch agnostic location.
  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'copy .net 5 projection DLL and PDB'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\signedbinaries_x86\lib\x86'
      Contents: |
        net5.0\Microsoft.ApplicationModel.Resources.Projection.pdb
        signed\net5.0\Microsoft.ApplicationModel.Resources.Projection.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\net5.0-windows\'
      flattenFolders: true

  # We build the projection binaries for AnyCPU. For convenience though, we group these binaries with other x86
  # binaries for signing. That's why we're copying from the x86 location but deploying to an arch agnostic location.
  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'copy .net 2 projection DLL and PDB'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\signedbinaries_x86\lib\x86'
      Contents: |
        netstandard2.0\Microsoft.ApplicationModel.Resources.Projection.pdb
        signed\netstandard2.0\Microsoft.ApplicationModel.Resources.Projection.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\netstandard2.0-windows\'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'copy x86'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\signedbinaries_x86\lib\x86'
      Contents: |
        mrm.pdb
        Microsoft.ApplicationModel.Resources.pdb
        signed\mrm.dll
        signed\Microsoft.ApplicationModel.Resources.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\runtimes\win10-x86\native'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'copy x64'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\signedbinaries_x64\lib\x64'
      Contents: |
        mrm.pdb
        Microsoft.ApplicationModel.Resources.pdb
        signed\mrm.dll
        signed\Microsoft.ApplicationModel.Resources.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\runtimes\win10-x64\native'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'copy ARM64'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\signedbinaries_ARM64\lib\ARM64'
      Contents: |
        mrm.pdb
        Microsoft.ApplicationModel.Resources.pdb
        signed\mrm.dll
        signed\Microsoft.ApplicationModel.Resources.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\runtimes\win10-arm64\native'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'copy import lib x86'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\signedbinaries_x86\lib\x86'
      Contents: |
        mrm.lib
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\win10-x86'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'copy import lib x64'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\signedbinaries_x64\lib\x64'
      Contents: |
        mrm.lib
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\win10-x64'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'copy import lib ARM64'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\signedbinaries_ARM64\lib\ARM64'
      Contents: |
        mrm.lib
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\win10-arm64'
      flattenFolders: true

  - task: DownloadBuildArtifacts@0
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'Download: Unsigned Binaries'
    inputs:
      buildType: 'current'
      downloadType: 'single'
      artifactName: 'binaries_raw'
      downloadPath: '$(Build.ArtifactStagingDirectory)\raw'

  # The winmd is arch agnostic. For signing convenience, we group it with the x86 binaries.
  # So, here, we copy from the x86 location to an arch agnostic location.
  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'copy unsigned winmd'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw\lib\x86'
      Contents: |
        Microsoft.ApplicationModel.Resources.winmd
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\uap10.0\'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'copy unsigned .net 5 projection DLL and PDB'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw\lib\x86'
      Contents: |
        net5.0\Microsoft.ApplicationModel.Resources.Projection.pdb
        net5.0\Microsoft.ApplicationModel.Resources.Projection.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\net5.0-windows\'
      flattenFolders: true

  # We build the projection binaries for AnyCPU. For signing convenience, we group these binaries with other x86
  # binaries. That's why we're copying from the x86 location but deploying to an arch agnostic location.
  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'copy unsigned .net 2 projection DLL and PDB'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw\lib\x86'
      Contents: |
        netstandard2.0\Microsoft.ApplicationModel.Resources.Projection.pdb
        netstandard2.0\Microsoft.ApplicationModel.Resources.Projection.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\netstandard2.0-windows\'
      flattenFolders: true

  # We build the projection binaries for AnyCPU. For signing convenience, we group these binaries with other x86
  # binaries. That's why we're copying from the x86 location but deploying to an arch agnostic location.
  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'copy unsigned x86'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw\lib\x86'
      Contents: |
        mrm.pdb
        Microsoft.ApplicationModel.Resources.pdb
        mrm.dll
        Microsoft.ApplicationModel.Resources.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\runtimes\win10-x86\native'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'copy unsigned x64'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw\lib\x64'
      Contents: |
        mrm.pdb
        Microsoft.ApplicationModel.Resources.pdb
        mrm.dll
        Microsoft.ApplicationModel.Resources.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\runtimes\win10-x64\native'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'copy unsigned ARM64'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw\lib\ARM64'
      Contents: |
        mrm.pdb
        Microsoft.ApplicationModel.Resources.pdb
        mrm.dll
        Microsoft.ApplicationModel.Resources.dll
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\runtimes\win10-arm64\native'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'copy unsigned import lib x86'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw\lib\x86'
      Contents: |
        mrm.lib
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\win10-x86'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'copy unsigned import lib x64'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw\lib\x64'
      Contents: |
        mrm.lib
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\win10-x64'
      flattenFolders: true

  - task: CopyFiles@2
    condition: and(succeeded(), eq(variables.codeSign, false))
    displayName: 'copy unsigned import lib ARM64'
    inputs:
      SourceFolder: '$(Build.ArtifactStagingDirectory)\raw\binaries_raw\lib\ARM64'
      Contents: |
        mrm.lib
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\lib\win10-arm64'
      flattenFolders: true

  - task: CopyFiles@2
    displayName: 'copy packaging files'
    inputs:
      SourceFolder: 'packaging'
      Contents: |
        Microsoft.ApplicationModel.Resources.props
        Microsoft.ApplicationModel.Resources.C.props
        Microsoft.ApplicationModel.Resources.PriGen.targets
        Microsoft.ApplicationModel.Resources.References.targets
        Microsoft.ApplicationModel.Resources.targets
        Microsoft.ApplicationModel.Resources.WinRt.props
        README.md
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\build'

  - task: CopyFiles@2
    displayName: 'copy header'
    inputs:
      SourceFolder: 'mrt\core\src'
      Contents: |
        mrm.h
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt\include'

  - task: CopyFiles@2
    displayName: 'copy license'
    inputs:
      Contents: |
        LICENSE.txt
      TargetFolder: '$(Build.ArtifactStagingDirectory)\mrt'

# END of copying files into their final package location.
  
  - task: NuGetCommand@2
    inputs:
      command: 'pack'
      packagesToPack: 'mrt\nuget\Microsoft.ApplicationModel.Resources.nuspec'
      versioningScheme: 'byPrereleaseNumber'
      majorVersion: '$(Major)'
      minorVersion: '$(Minor)'
      patchVersion: '$(Patch)'
      basePath: '$(Build.ArtifactStagingDirectory)\mrt'
      packDestination: '$(Build.ArtifactStagingDirectory)\nuget'
  
  - task: PkgESCodeSign@10
    condition: and(succeeded(), eq(variables.codeSign, true))
    env:
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    inputs:
      signConfigXml: 'SignConfig-nuget.xml'
      inPathRoot: '$(BUILD.ArtifactStagingDirectory)\nuget'
      outPathRoot: '$(BUILD.ArtifactStagingDirectory)\nuget'
  
  - task: PublishBuildArtifacts@1
    condition: and(succeeded(), eq(variables.codeSign, false))
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)\nuget'
      ArtifactName: 'drop'

  - task: PublishBuildArtifacts@1
    condition: and(succeeded(), eq(variables.codeSign, true))
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)\nuget\signed'
      ArtifactName: 'drop'

  - task: NuGetCommand@2
    condition: and(succeeded(), eq(variables.codeSign, true))
    displayName: 'publish to MRTCore feed'
    inputs:
      command: 'push'
      packagesToPush: '$(Build.ArtifactStagingDirectory)/nuget/signed/*.nupkg;!$(Build.ArtifactStagingDirectory)/**/*.symbols.nupkg'
      nuGetFeedType: 'internal'
      publishVstsFeed: '2771a91e-5705-4d88-a3e9-70623b166f8d/659bea81-0d99-4dc0-b32f-200cd635e5ad'

# TODO: get the test app to build using the NuGet package generated earlier in the pipeline.
#- task: NuGetCommand@2
#  displayName: 'NuGet restore of test apps'
#  env:
#    # The RuntimeIdentifier property in a .csproj is constructed using win-$(Platform). AnyCPU is the default platform, but
#    # "win-AnyCPU" is an invalid RuntimeIdentifier. Just use the platform x64 instead! It doesn't matter whether x86 or x64 is used.
#    NUGET_RESTORE_MSBUILD_ARGS: /p:Platform=x64
#  inputs:
#    command: 'restore'
#    restoreSolution: |
#      '$(Build.SourcesDirectory)\tools\TestApps\winui_desktop_packaged_app\winui_desktop_packaged_app.sln'
#      '$(Build.SourcesDirectory)\tools\TestApps\winui_desktop_packaged_app\winui_desktop_packaged_app_cpp.sln'
#    feedsToUse: 'select'
#    includeNuGetOrg: false
#    vstsFeed: '$(Build.ArtifactStagingDirectory)\nuget'

# TODO: use the $(solution) variable instead. That'll build all solution files in the repo. Currently, this isn't being done because getting
# $(Build.SourcesDirectory)\tools\TestApps\winui_desktop_packaged_app\winui_desktop_packaged_app.sln to build in the pipeline is being deferred.

#- task: VSBuild@1
#  displayName: 'build x86'
#  inputs:
#    platform: 'x86'
#    solution: |
#      '$(Build.SourcesDirectory)\tools\TestApps\winui_desktop_packaged_app\winui_desktop_packaged_app.sln'
#      '$(Build.SourcesDirectory)\tools\TestApps\winui_desktop_packaged_app\winui_desktop_packaged_app_cpp.sln'
#    configuration: '$(buildConfiguration)'
#    msbuildArgs: '/p:AppxBundlePlatforms="x86" /p:AppxPackageDir="$(appxPackageDir)" /p:AppxBundle=Always /p:UapAppxPackageBuildMode=StoreUpload'

#- task: VSBuild@1
#  displayName: 'build x64'
#  inputs:
#    platform: 'x64'
#    solution: |
#      '$(Build.SourcesDirectory)\tools\TestApps\winui_desktop_packaged_app\winui_desktop_packaged_app.sln'
#      '$(Build.SourcesDirectory)\tools\TestApps\winui_desktop_packaged_app\winui_desktop_packaged_app_cpp.sln'
#    configuration: '$(buildConfiguration)'
#    msbuildArgs: '/p:AppxBundlePlatforms="x64" /p:AppxPackageDir="$(appxPackageDir)" /p:AppxBundle=Always /p:UapAppxPackageBuildMode=StoreUpload'

  - task: PkgESSerializeForPostBuild@10
    displayName: 'PkgES Post Build Serialization'
    continueOnError: true

  - task: PkgESLateTasks@10
    displayName: 'PkgES Finalize and Cleanup'
    inputs:
      enablePostBuild: false
      dfsReleaseInPb: true
